<?php

namespace Phine\Phar;

use Phine\Exception\Exception;
use Phine\Phar\Exception\FileException;
use Phine\Phar\File\Writer;
use Phine\Phar\Manifest\Entry;

/**
 * Extracts the contents of an archive.
 *
 * Summary
 * -------
 *
 * The `Extract` class utilizes the `Archive` and `Entry` class to extract
 * one or more files from an archive file, without using the `phar` extension.
 * Unlike the extraction class that is bundled with the default archive stub
 * generated by the extension, heavy error checking is performed in order to
 * prevent memory exhaustion when a corrupted archive is used.
 *
 * Starting
 * --------
 *
 * To create a new instance of this class, you will need to provide a archive:
 *
 *     use Phine\Phar\Extract;
 *     use Phine\Phar\File\Reader;
 *     use Phine\Phar\Archive;
 *
 *     $reader = new Reader('example.phar');
 *     $archive = new Archive($reader);
 *     $extract = new Extract($archive);
 *
 * @author Kevin Herrera <kevin@herrera.io>
 *
 * @api
 */
class Extract
{
    /**
     * The archive file reader.
     *
     * @var Archive
     */
    private $archive;

    /**
     * The list of support compression algorithms.
     *
     * @var array
     */
    private static $compression;

    /**
     * Sets the archive file reader.
     *
     * This method will set the archive file reader that will be used to
     * extract one or more files.
     *
     *     use Phine\Phar\Extract;
     *     use Phine\Phar\File\Reader;
     *     use Phine\Phar\Archive;
     *
     *     $reader = new Reader('example.phar');
     *     $archive = new Archive($reader);
     *     $extract = new Extract($archive);
     *
     * @param Archive $archive The archive file reader.
     *
     * @api
     */
    public function __construct(Archive $archive)
    {
        $this->archive = $archive;
    }

    /**
     * Returns the contents of a file from an archive.
     *
     * Uses an instance of `Entry` to extract and decompress (if necessary)
     * the contents of a file from an archive. Note that an extension may be
     * required (`bz2` or `zlib`) to extract the file.
     *
     *     use Phine\Phar\Extract;
     *
     *     $contents = Extract::extractFile($entry);
     *
     * @param Entry $entry The file information from the archive.
     *
     * @return string The decompressed file contents.
     *
     * @throws Exception
     * @throws FileException If the file could not be decompressed.
     *
     * @api
     */
    public static function extractFile(Entry $entry)
    {
        if (null === self::$compression) {
            self::$compression = array(
                'bzip2' => function_exists('bzdecompress'),
                'gzip' => function_exists('gzinflate'),
            );
        }

        $reader = $entry->getArchive()->getReader();

        $reader->seek($entry->getOffset());

        $contents = $reader->read($entry->getCompressedSize());

        if ($entry->isCompressed(Entry::BZ2)) {
            if (!self::$compression['bzip2']) {
                throw FileException::createUsingFormat(
                    'The "bz2" extension is required to decompress "%s".',
                    $entry->getName()
                );
            }

            $contents = bzdecompress($contents);
        } elseif ($entry->isCompressed(Entry::GZ)) {
            if (!self::$compression['gzip']) {
                throw FileException::createUsingFormat(
                    'The "zlib" extension is required to decompress "%s".',
                    $entry->getName()
                );
            }

            $contents = gzinflate($contents);
        }

        return $contents;
    }

    /**
     * Extracts one or more files to an output directory.
     *
     * If a `$filter` callable is provided, it will be called with each file
     * found in the archive.  If `true` is returned by the filter, the file
     * will not be extracted. If any other value is returned, the file will
     * be extracted.
     *
     *     use Phine\Phar\Manifest\Entry;
     *
     *     $fileCount = $extract->extractTo(
     *         '/path/to/output/dir',
     *         function (Entry $entry) {
     *             if (!preg_match('/Test/', $entry->getName()) {
     *                 return true; // skip this file
     *             }
     *         }
     *     );
     *
     * @param string   $dir               The output directory path.
     * @param callable $filter (optional) The callable used to filter files.
     *
     * @return integer The number of files extracted.
     *
     * @throws Exception
     * @throws FileException If a file could not be extracted.
     *
     * @api
     */
    public function extractTo($dir, $filter = null)
    {
        $files = $this->archive->getEntries();
        $count = 0;

        foreach ($files as $file) {
            if ($filter && (true === $filter($file))) {
                continue;
            }

            $path = $dir . '/' . $file->getName();
            $base = dirname($path);

            if (!is_dir($base)) {
                if (!@mkdir($base, 0755, true)) {
                    throw FileException::createUsingLastError();
                }
            }

            $writer = new Writer($path);
            $writer->write(self::extractFile($file));

            $count++;
        }

        return $count;
    }

    /**
     * Returns the archive for the archive file.
     *
     * This method will return the archive file reader used to extract one or
     * more files.
     *
     *     $archive = $extract->getArchive();
     *
     * @return Archive The archive for the archive file.
     *
     * @api
     */
    public function getArchive()
    {
        return $this->archive;
    }
}
